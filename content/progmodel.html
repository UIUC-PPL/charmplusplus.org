--- 
title: Programming Model
---

<h1>Programming Model</h1>

<h4>Object-based program design</h4>
<ul>
<li>Express algorithms and program designs using objects</li>
<li>Decompose computation into interacting object collections</li>
<li>Write native C++ code</li>
<li>Use all C++ capabilities (OO, generics etc)</li>
</ul>

<h4>Globally addressable objects</h4>
<ul>
<li>Some classes are elevated into global visibility</li>
<li>Objects of these classes can be addressed from any processor</li>
<li>Parallel control flow primarily involves these globally visible objects</li>
</ul>

<h4>Globally invocable methods</h4>
<ul>
<li>Some methods of globally visible classes are also elevated into global visibility</li>
<li>Only these methods of a globally visible object can be invoked from any processor</li>
</ul>

<h4>Asynchronous methods</h4>
<ul>
<li>Objects in computation interact using method invocations</li>
<li>Do not return any data</li>
<li>Method invocation does not block</li>
<li>No promise of immediate execution</li>
</ul>

<h4>Object collections</h4>
<ul>
<li>Collections of objects of a given type can be created, managed and addressed collectively</li>
<li>Collections are indexed</li>
<li>Each object in collection is globally visible. can be addressed via the tuple of collection handle and object index.</li>
<li>Method invocations on such collections are implicit broadcasts to all objects</li>
</ul>

<figure>
<img src="../figs/sysviewvsprogview.png" width=600>
<figcaption>Figure: User view and system view in Charm++</figcaption>
</figure>

<h4>Object placement</h4>
<ul>
<li>Easily control placement of objects on processors</li>
</ul>

<h4>Migratable / serializable objects</h4>
<ul>
<li>Objects can be migrated</li>
<li>Any data in program can be migrated</li>
<li>Simply needs a serialization function</li>
</ul>

<h4>Decompose data across object collection</h4>
<ul>
<li>Typical data decomposition is by decomposing the data across multiple objects of a single class</li>
<li>Massively parallel computations on each portion of the data can be performed by simply invoking methods on the whole collection</li>
</ul>

<h4>Decompose data manipulation across methods</h4>

<h4>Easily task parallelism</h4>

