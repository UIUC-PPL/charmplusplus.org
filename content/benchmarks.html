--- 
title: Mini-Apps
homec: home 
tutorialc: tutorial 
applicationsc: applications 
benchmarksc: benchmarks selected benchmarksSelected
downloadc: download
toolsc: tools
helpc: help
---

<!-- <ul> -->
<!-- <div id="hpc"><h2>HPC Challenge</h2> -->
<!-- <p> -->
<!-- Our HPC Challenge suit consists of various benchmarks that demonstrate productivity and performance in a -->
<!-- parallel programming system. -->
<!-- </p> -->
<!-- <br> -->

<div class="bench-list">
<ul>
<li><a href="#leanmd">LeanMD - molecular dynamics</a></li>
<li><a href="#amr">AMR - adaptive mesh refinement</a></li>
<li><a href="#barnes">Barnes Hut - n-body problem</a></li>
<li><a href="#denselu">DenseLU - matrix solver (HPC Challenge)</a></li>
<li><a href="#hpccg">HPCCG - conjugant gradient (Mantevo)</a></li>
<li><a href="#solver">TS - triangular solver</a></li>
<li><a href="#fft">FFT - one dimensional FFT (HPC Challenge)</a></li>
<li><a href="#random">RA - random access (HPC Challenge)</a></li>
<li><a href="#stream">EP - stream (HPC Challenge)</a></li>
</ul>

<a name="leanmd"></a>
<div class="benchmark">
  <h2>LeandMD</h2>
  <p>LeanMD is a molecular dynamics simulation program written in Charm++. This benchmark 
  simulates the behavior of atoms based on the Lennard-Jones potential, which is an effective 
  potential that describes the interaction between two uncharged molecules or atoms. 
  The computation performed in this code mimics the short-range non-bonded force calculation 
  in NAMD, and resembles the LJ force computation in miniMD benchmark in the Mantevo benchmark suite 
  maintained by Sandia National Laboratories. 
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/leanmd.git</div>
</div>

<a name="amr"></a>
<div class="benchmark">
  <h2>AMR</h2>
  <p> This benchmarks is mesh restructuring algorithm for adaptive mesh
    refinement computations. The parallel mesh restructuring algorithm operates
    in terms of near-neighbor communication among individual blocks, and a
    single synchronization-only collective. </p>
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/amr.git</div>
</div>

<a name="barnes"></a>
<div class="benchmark">
  <h2>Barnes-Hut</h2>
  <p> The Barnes-Hut algorithm is a tree-based scheme to compute fast and
    approximate time-series solutions to the N-body problem, where Barnes-Hut
    algorithm for N-body problem is a method of calculating forces on a system
    of N bodies that grows only as N log N. It uses a tree-structured
    hierarchical recursive subdivision of space into cubic cells. Barnes-Hut
    method is widely used in cosmological simulations. </p>
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/barnes.git</div>
</div>

<a name="denselu"></a>
<div class="benchmark">
  <h2>Dense LU</h2>	 	
  <div class="giturl">git://charm.cs.illinois.edu/charmlu.git</div>
</div>

<a name="hpccg"></a>
<div class="benchmark">
  <h2>hpccg</h2>
  <div class="giturl">https://charm.cs.uiuc.edu/private/gitweb2.cgi?p=users/lifflander/hpccg.git;a=summary</div>
</div>

<a name="solver"></a>
<div class="benchmark">
  <h2>Triangular Solver</h2>
  <p> Solution of sparse triangular systems of linear equations is a
    performance bottleneck in many methods for solving more general sparse
    systems, such as many iterative methods with preconditioners.  The matrix
    is divided into blocks of columns. Each block is analyzed to find its
    independent rows for computation. If there are dense regions below the
    diagonal section (we assume lower triangular for description), they are
    divided into new blocks. Each diagonal block starts the computation with
    its independent parts and waits for its dependency messages from the left.
    Nondiagonal blocks wait for the solution values from their corresponding
    diagonal block, and then start their computation (and receipt of other
    messages). </p>
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/triangularsolver.git</div>
</div>

<a name="fft"></a>
<div class="benchmark">
  <h2>1D FFT</h2>
  <p> Our implementation of Global FFT takes input size N and performs a
  complex 1D FFT on an NxN matrix where subsequent rows are contiguous data
  elements of a double precision complex vector. Three all-to-all transposes
  are required to perform the FFT and unscramble the data.  All-to-all
  operations are executed via point-to-point messages and external libraries
  (FFTW or ESSL) perform serial FFTs on the rows of the matrix. </p>
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/fft-trans.git</div>
</div>

<a name="random"></a>
<div class="benchmark">
  <h2>Random Access</h2>
  <p> For Random Access benchmark we use the Mesh Streamer library for
    optimizing all-to-all communication on small messages. </p>
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/randomAccess.git</div>
</div>

<a name="stream"></a>
<div class="benchmark">
  <h2>EP Stream</h2>
  <div class="giturl">git://charm.cs.illinois.edu/benchmarks/hpccstream.git</div>
</div>

